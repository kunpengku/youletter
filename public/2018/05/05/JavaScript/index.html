<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle = window.adsbygoogle || []).push({
google_ad_client: "ca-pub-7674654031652018",
enable_page_level_ads: true
});
</script><script>(function(){
var bp = document.createElement('script');
var curProtocol = window.location.protocol.split(':')[0];
if (curProtocol === 'https'){
bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
}
else{
bp.src = 'http://push.zhanzhang.baidu.com/push.js';
}
var s = document.getElementsByTagName("script")[0];
s.parentNode.insertBefore(bp, s);
})();
</script><title> JavaScript · 由来</title><meta name="description" content="JavaScript - kunpengku"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/prontera.css"><link rel="search" type="application/opensearchdescription+xml" href="http://www.youletter.cn/atom.xml" title="由来"></head><body><header class="feature-header"><nav class="component-nav"><ul><div class="logo-container"><a href="/"><h2 class="title">由来</h2></a></div><a href="/" target="_self" class="li component-nav-item"><p>主页</p></a><a href="/archives" target="_self" class="li component-nav-item"><p>归档</p></a><a href="/about" target="_self" class="li component-nav-item"><p>关于我</p></a><ul class="shortcut-icons"><a href="https://github.com/kunpengku" target="_blank"><img src="/images/github.svg" class="icon"></a><a href="/atom.xml" target="_blank"><img src="/images/rss.svg" class="icon"></a></ul></ul></nav></header><main class="container"><div id="post-container"><div class="post"><article class="post-block"><h1 class="post-title">JavaScript</h1><div class="post-info">2018年5月5日</div><div class="post-content"><p>一般来说，完整的JavaScript包括以下几个部分：</p>
<p>ECMAScript，描述了该语言的语法和基本对象<br>文档对象模型（DOM），描述处理网页内容的方法和接口  Document Object Model<br>浏览器对象模型（BOM），描述与浏览器进行交互的方法和接口 Browser Object Model </p>
<p>基本语法</p>
<p>每个语句以;结束 ，但是负责执行JavaScript代码的引擎会自动在每个语句的结尾补上; 。所以你可以选择不写 ;。</p>
<p>注释</p>
<p>以//开头直到行末的字符被视为行注释</p>
<p>另一种块注释是用/<em>…</em>/把多行字符包裹起来，把一大“块”视为一个注释：</p>
<p>JavaScript严格区分大小写</p>
<p>数据类型</p>
<p>JavaScript不区分整数和浮点数，统一用Number表示</p>
<p>字符串<br>字符串是以单引号’或双引号”括起来的任意文本，比如’abc’，”xyz”等等</p>
<p>布尔值<br>布尔值和布尔代数的表示完全一致，一个布尔值只有true、false</p>
<p>&amp;&amp;  与</p>
<p>||  或</p>
<p>！  非</p>
<p>JS的语法就像C语言。</p>
<p>JavaScript在设计时，有两种比较运算符：</p>
<p>第一种是==比较，它会自动转换数据类型再比较，很多时候，会得到非常诡异的结果；</p>
<p>第二种是===比较，它不会自动转换数据类型，如果数据类型不一致，返回false，如果一致，再比较。</p>
<p>不要使用==比较，始终坚持使用===比较。</p>
<p>另一个例外是NaN这个特殊的Number与所有其他值都不相等，包括它自己：</p>
<p>NaN === NaN; // false</p>
<p>唯一能判断NaN的方法是通过isNaN()函数：</p>
<p>isNaN(NaN); // true</p>
<p>null和undefined</p>
<p>数组</p>
<p>[1, 2, 3.14, ‘Hello’, null, true];<br>JavaScript的数组可以包括任意数据类型。  而且数组中的类型不必 相同。</p>
<p>另一种创建数组的方法是通过Array()函数实现：</p>
<p>new Array(1, 2, 3); // 创建了数组[1, 2, 3]</p>
<p>对象<br>JavaScript的对象是一组由键-值组成的无序集合，例如：</p>
<p>var person = {<br>    name: ‘Bob’,<br>    age: 20,<br>    tags: [‘js’, ‘web’, ‘mobile’],<br>    city: ‘Beijing’,<br>    hasCar: true,<br>    zipcode: null<br>};</p>
<p>JavaScript对象的键都是字符串类型，值可以是任意数据类型</p>
<p>要获取一个对象的属性，我们用对象变量.属性名的方式：</p>
<p>person.name; // ‘Bob’<br>person.zipcode; // null</p>
<p>变量在JavaScript中就是用一个变量名表示，变量名是大小写英文、数字、$和_的组合，且不能用数字开头。变量名也不能是JavaScript的关键字，如if、while等。申明一个变量用var语句，比如：</p>
<p>var a; // 申明了变量a，此时a的值为undefined<br>var $b = 1; // 申明了变量$b，同时给$b赋值，此时$b的值为1<br>var s_007 = ‘007’; // s_007是一个字符串<br>var Answer = true; // Answer是一个布尔值true<br>var t = null; // t的值是null</p>
<p>如果一个变量没有通过var申明就被使用，那么该变量就自动被申明为全局变量：</p>
<p>strict模式</p>
<p>字符串</p>
<p>多行字符串</p>
<p>ES6标准新增了一种多行字符串的表示方法，用反引号 <code>...</code> 表示：</p>
<p><code>这是一个
多行
字符串</code>;</p>
<p>模板字符串</p>
<p>name = ‘fupeng’</p>
<p>age=’12a’</p>
<p>console.log(<code>你好, ${name}, 你今年${age}岁了!</code>);</p>
<p>请注意，如果通过索引赋值时，索引超过了范围，同样会引起Array大小的变化：</p>
<p>var arr = [1, 2, 3];<br>arr[5] = ‘x’;<br>arr; // arr变为[1, 2, 3, undefined, undefined, ‘x’]</p>
<p>push和pop<br>push()向Array的末尾添加若干元素，pop()则把Array的最后一个元素删除掉：</p>
<p>var arr = [1, 2];<br>arr.push(‘A’, ‘B’); // 返回Array新的长度: 4<br>arr; // [1, 2, ‘A’, ‘B’]<br>arr.pop(); // pop()返回’B’<br>arr; // [1, 2, ‘A’]<br>arr.pop(); arr.pop(); arr.pop(); // 连续pop 3次<br>arr; // []<br>arr.pop(); // 空数组继续pop不会报错，而是返回undefined<br>arr; // []</p>
<p>unshift和shift<br>如果要往Array的头部添加若干元素，使用unshift()方法，shift()方法则把Array的第一个元素删掉：</p>
<p>var arr = [1, 2];<br>arr.unshift(‘A’, ‘B’); // 返回Array新的长度: 4<br>arr; // [‘A’, ‘B’, 1, 2]<br>arr.shift(); // ‘A’<br>arr; // [‘B’, 1, 2]<br>arr.shift(); arr.shift(); arr.shift(); // 连续shift 3次<br>arr; // []<br>arr.shift(); // 空数组继续shift不会报错，而是返回undefined<br>arr; // []</p>
<p>concat<br>concat()方法把当前的Array和另一个Array连接起来，并返回一个新的Array：</p>
<p>var arr = [‘A’, ‘B’, ‘C’];<br>var added = arr.concat([1, 2, 3]);<br>added; // [‘A’, ‘B’, ‘C’, 1, 2, 3]<br>arr; // [‘A’, ‘B’, ‘C’]</p>
<p>join<br>join()方法是一个非常实用的方法，它把当前Array的每个元素都用指定的字符串连接起来，然后返回连接后的字符串：</p>
<p>var arr = [‘A’, ‘B’, ‘C’, 1, 2, 3];<br>arr.join(‘-‘); // ‘A-B-C-1-2-3’</p>
<p>对象</p>
<p>JavaScript用一个{…}表示一个对象，键值对以xxx: xxx形式申明，用,隔开。</p>
<p>var xiaoming = {<br>    name: ‘小明’,<br>    birth: 1990,<br>    school: ‘No.1 Middle School’,<br>    height: 1.70,<br>    weight: 65,<br>    score: null<br>};</p>
<p>但这要求属性名必须是一个有效的变量名。如果属性名包含特殊字符，就必须用’’括起来：</p>
<p>var xiaohong = {<br>    name: ‘小红’,<br>    ‘middle-school’: ‘No.1 Middle School’<br>};</p>
<p>我们在编写JavaScript代码的时候，属性名尽量使用标准的变量名，这样就可以直接通过object.prop的形式访问一个属性了。</p>
<p>实际上JavaScript对象的所有属性都是字符串，不过属性对应的值可以是任意数据类型。</p>
<p>由于JavaScript的对象是动态类型，你可以自由地给一个对象添加或删除属性：</p>
<p>var xiaoming = {<br>    name: ‘小明’<br>};<br>xiaoming.age; // undefined<br>xiaoming.age = 18; // 新增一个age属性<br>xiaoming.age; // 18<br>delete xiaoming.age; // 删除age属性<br>xiaoming.age; // undefined<br>delete xiaoming[‘name’]; // 删除name属性<br>xiaoming.name; // undefined<br>delete xiaoming.school; // 删除一个不存在的school属性也不会报错</p>
<p>如果我们要检测xiaoming是否拥有某一属性，可以用in操作符：</p>
<p>var xiaoming = {<br>    name: ‘小明’,<br>    birth: 1990,<br>    school: ‘No.1 Middle School’,<br>    height: 1.70,<br>    weight: 65,<br>    score: null<br>};<br>‘name’ in xiaoming; // true<br>‘grade’ in xiaoming; // false</p>
<p>要判断一个属性是否是xiaoming自身拥有的，而不是继承得到的，可以用hasOwnProperty()方法：</p>
<p>var xiaoming = {<br>    name: ‘小明’<br>};<br>xiaoming.hasOwnProperty(‘name’); // true<br>xiaoming.hasOwnProperty(‘toString’); // false</p>
<p>条件判断</p>
<p>var age = 20;<br>if (age &gt;= 18) { // 如果age &gt;= 18为true，则执行if语句块<br>    alert(‘adult’);<br>} else { // 否则执行else语句块<br>    alert(‘teenager’);<br>}</p>
<p>循环</p>
<p>var x = 0;<br>var i;<br>for (i=1; i&lt;=10000; i++) {<br>    x = x + i;<br>}<br>x;</p>
<p>for循环最常用的地方是利用索引来遍历数组：</p>
<p>var arr = [‘Apple’, ‘Google’, ‘Microsoft’];<br>var i, x;<br>for (i=0; i&lt;arr.length; i++) {<br>    x = arr[i];<br>    console.log(x);<br>}</p>
<p>var a = [‘A’, ‘B’, ‘C’];<br>for (var i in a) {<br>    console.log(i); // ‘0’, ‘1’, ‘2’<br>    console.log(a[i]); // ‘A’, ‘B’, ‘C’<br>}</p>
<p>while<br>for循环在已知循环的初始和结束条件时非常有用。而上述忽略了条件的for循环容易让人看不清循环的逻辑，此时用while循环更佳。</p>
<p>while循环只有一个判断条件，条件满足，就不断循环，条件不满足时则退出循环。比如我们要计算100以内所有奇数之和，可以用while循环实现：</p>
<p>var x = 0;<br>var n = 99;<br>while (n &gt; 0) {<br>    x = x + n;<br>    n = n - 2;<br>}<br>x; // 2500</p>
<p>Map<br>Map是一组键值对的结构，具有极快的查找速度。</p>
<p>初始化Map需要一个二维数组，或者直接初始化一个空Map。</p>
<p>var m = new Map([[‘Michael’, 95], [‘Bob’, 75], [‘Tracy’, 85]]);<br>m.get(‘Michael’); // 95</p>
<p>var m = new Map(); // 空Map<br>m.set(‘Adam’, 67); // 添加新的key-value<br>m.set(‘Bob’, 59);<br>m.has(‘Adam’); // 是否存在key ‘Adam’: true<br>m.get(‘Adam’); // 67<br>m.delete(‘Adam’); // 删除key ‘Adam’<br>m.get(‘Adam’); // undefined</p>
<p>Set<br>Set和Map类似，也是一组key的集合，但不存储value。</p>
<p>小结<br>Map和Set是ES6标准新增的数据类型，</p>
<p>定义函数</p>
<p>function abs(x) {<br>    if (x &gt;= 0) {<br>        return x;<br>    } else {<br>        return -x;<br>    }<br>}</p>
<p>由于JavaScript的函数也是一个对象，上述定义的abs()函数实际上是一个函数对象，而函数名abs可以视为指向该函数的变量。</p>
<p>因此，第二种定义函数的方式如下：</p>
<p>var abs = function (x) {<br>    if (x &gt;= 0) {<br>        return x;<br>    } else {<br>        return -x;<br>    }<br>};</p>
<p>由于JavaScript允许传入任意个参数而不影响调用，因此传入的参数比定义的参数多也没有问题，虽然函数内部并不需要这些参数：</p>
<p>abs(10, ‘blablabla’); // 返回10<br>abs(-9, ‘haha’, ‘hehe’, null); //</p>
<p>arguments<br>JavaScript还有一个免费赠送的关键字arguments，它只在函数内部起作用，并且永远指向当前函数的调用者传入的所有参数。arguments类似Array但它不是一个Array</p>
<p>function foo(x) {<br>    console.log(‘x = ‘ + x); // 10<br>    for (var i=0; i&lt;arguments.length; i++) {<br>        console.log(‘arg ‘ + i + ‘ = ‘ + arguments[i]); // 10, 20, 30<br>    }<br>}<br>foo(10, 20, 30);</p>
<p>在JavaScript中，用var申明的变量实际上是有作用域的。</p>
<p>如果一个变量在函数体内部申明，则该变量的作用域为整个函数体，在函数体外不可引用该变量：</p>
<p>由于JavaScript的函数可以嵌套，此时，内部函数可以访问外部函数定义的变量，反过来则不行：</p>
<p>‘use strict’;</p>
<p>function foo() {<br>    var x = 1;<br>    function bar() {<br>        var y = x + 1; // bar可以访问foo的变量x!<br>    }<br>    var z = y + 1; // ReferenceError! foo不可以访问bar的变量y!<br>}</p>
<p>这说明JavaScript的函数在查找变量时从自身函数定义开始，从“内”向“外”查找。如果内部函数定义了与外部函数重名的变量，则内部函数的变量将“屏蔽”外部函数的变量。</p>
<p>变量提升</p>
<p>这正是因为JavaScript引擎自动提升了变量y的声明，但不会提升变量y的赋值。</p>
<p>全局作用域<br>不在任何函数内定义的变量就具有全局作用域。实际上，JavaScript默认有一个全局对象window，全局作用域的变量实际上被绑定到window的一个属性：</p>
<p>‘use strict’;</p>
<p>var course = ‘Learn JavaScript’;<br>alert(course); // ‘Learn JavaScript’<br>alert(window.course); // ‘Learn JavaScript’</p>
<p>这说明JavaScript实际上只有一个全局作用域。</p>
<p>名字空间<br>全局变量会绑定到window上，不同的JavaScript文件如果使用了相同的全局变量，或者定义了相同名字的顶层函数，都会造成命名冲突，并且很难被发现。</p>
<p>减少冲突的一个方法是把自己的所有变量和函数全部绑定到一个全局变量中。例如：</p>
<p>// 唯一的全局变量MYAPP:<br>var MYAPP = {};</p>
<p>// 其他变量:<br>MYAPP.name = ‘myapp’;<br>MYAPP.version = 1.0;</p>
<p>// 其他函数:<br>MYAPP.foo = function () {<br>    return ‘foo’;<br>};</p>
<p>为了解决块级作用域，ES6引入了新的关键字let，用let替代var可以申明一个块级作用域的变量：</p>
<p>‘use strict’;</p>
<p>function foo() {<br>    var sum = 0;<br>    for (let i=0; i&lt;100; i++) {<br>        sum += i;<br>    }<br>    // SyntaxError:<br>    i += 1;<br>}</p>
<p>ES6标准引入了新的关键字const来定义常量，const与let都具有块级作用域：</p>
<p>‘use strict’;</p>
<p>const PI = 3.14;<br>PI = 3; // 某些浏览器不报错，但是无效果！<br>PI; // 3.14</p>
<p>解构赋值  很奇怪</p>
<p>要保证this指向正确，必须用obj.xxx()的形式调用！</p>
<p>apply<br>虽然在一个独立的函数调用中，根据是否是strict模式，this指向undefined或window，不过，我们还是可以控制this的指向的！</p>
<p>要指定函数的this指向哪个对象，可以用函数本身的apply方法，它接收两个参数，第一个参数就是需要绑定的this变量，第二个参数是Array，表示函数本身的参数。</p>
<p>装饰器<br>利用apply()，我们还可以动态改变函数的行为。</p>
<p>高阶函数英文叫Higher-order function。</p>
<p>编写高阶函数，就是让函数的参数能够接收别的函数。</p>
<p>利用filter，可以巧妙地去除Array的重复元素：<br>r = arr.filter(function (element, index, self) {<br>    return self.indexOf(element) === index;<br>});</p>
<p>要按数字大小排序，我们可以这么写</p>
<p>arr.sort(function (x, y) {<br>    if (x &lt; y) {<br>        return -1;<br>    }<br>    if (x &gt; y) {<br>        return 1;<br>    }<br>    return 0;<br>});<br>console.log(arr); // [1, 2, 10, 20]</p>
<p>闭包Closure</p>
<p>我们在函数lazy_sum中又定义了函数sum，并且，内部函数sum可以引用外部函数lazy_sum的参数和局部变量，当lazy_sum返回函数sum时，相关参数和变量都保存在返回的函数中，这种称为“闭包（Closure）”的程序结构拥有极大的威力。</p>
<p>function lazy_sum(arr) {<br>    var sum = function () {<br>        return arr.reduce(function (x, y) {<br>            return x + y;<br>        });<br>    }<br>    return sum;<br>}</p>
<p>var f = lazy_sum([1, 2, 3, 4, 5]); // function sum()</p>
<p>f()</p>
<p>返回闭包时牢记的一点就是：返回函数不要引用任何循环变量，或者后续会发生变化的变量。</p>
<p>通常，一个立即执行的匿名函数可以把函数体拆开，一般这么写：</p>
<p>(function (x) {<br>    return x * x;<br>})(3);</p>
<p>换句话说，闭包就是携带状态的函数，并且它的状态可以完全对外隐藏起来。</p>
<p>箭头函数</p>
<p>‘use strict’;<br>function* next_id() {</p>
<p>   var c = 0;</p>
<pre><code>while (true) {
    c++;
    yield c;

}
</code></pre><p>}</p>
<p>生成器就是一个 会暂停的函数 。</p>
<p>我们用typeof操作符获取对象的类型，它总是返回一个字符串：</p>
<p>typeof 123; // ‘number’<br>typeof NaN; // ‘number’<br>typeof ‘str’; // ‘string’<br>typeof true; // ‘boolean’<br>typeof undefined; // ‘undefined’<br>typeof Math.abs; // ‘function’<br>typeof null; // ‘object’<br>typeof []; // ‘object’<br>typeof {}; // ‘object’</p>
<p>number、boolean和string都有包装对象。</p>
<p>var n = new Number(123); // 123,生成了新的包装类型<br>var b = new Boolean(true); // true,生成了新的包装类型<br>var s = new String(‘str’); // ‘str’,生成了新的包装类型</p>
<p>如果我们在使用Number、Boolean和String时，没有写new会发生什么情况？</p>
<p>此时，Number()、Boolean和String()被当做普通函数，把任何类型的数据转换为number、boolean和string类型（注意不是其包装类型）：</p>
<p>var n = Number(‘123’); // 123，相当于parseInt()或parseFloat()<br>typeof n; // ‘number’</p>
<p>var b = Boolean(‘true’); // true<br>typeof b; // ‘boolean’</p>
<p>var b2 = Boolean(‘false’); // true! ‘false’字符串转换结果为true！因为它是非空字符串！<br>var b3 = Boolean(‘’); // false</p>
<p>var s = String(123.45); // ‘123.45’<br>typeof s; // ‘string’</p>
<p>不要使用new Number()、new Boolean()、new String()创建包装对象；</p>
<p>用parseInt()或parseFloat()来转换任意类型到number；</p>
<p>用String()来转换任意类型到string，或者直接调用某个对象的toString()方法；</p>
<p>通常不必把任意类型转换为boolean再判断，因为可以直接写if (myVar) {…}；</p>
<p>typeof操作符可以判断出number、boolean、string、function和undefined；</p>
<p>判断Array要使用Array.isArray(arr)；</p>
<p>判断null请使用myVar === null；</p>
<p>判断某个全局变量是否存在用typeof window.myVar === ‘undefined’；</p>
<p>函数内部判断某个变量是否存在用typeof myVar === ‘undefined’。</p>
<p>123.toString(); // SyntaxError<br>遇到这种情况，要特殊处理一下：</p>
<p>123..toString(); // ‘123’, 注意是两个点！<br>(123).toString(); // ‘123’<br>不要问为什么，这就是JavaScript代码的乐趣！</p>
<p>Date</p>
<p>在JavaScript中，Date对象用来表示日期和时间。</p>
<p>要获取系统当前时间，用：</p>
<p>var now = new Date();<br>now; // Wed Jun 24 2015 19:49:22 GMT+0800 (CST)<br>now.getFullYear(); // 2015, 年份<br>now.getMonth(); // 5, 月份，注意月份范围是0~11，5表示六月<br>now.getDate(); // 24, 表示24号<br>now.getDay(); // 3, 表示星期三<br>now.getHours(); // 19, 24小时制<br>now.getMinutes(); // 49, 分钟<br>now.getSeconds(); // 22, 秒<br>now.getMilliseconds(); // 875, 毫秒数<br>now.getTime(); // 1435146562875, 以number形式表示的时间戳</p>
<p>如果要创建一个指定日期和时间的Date对象，可以用：</p>
<p>var d = new Date(2015, 5, 19, 20, 15, 30, 123);<br>d; // Fri Jun 19 2015 20:15:30 GMT+0800 (CST)</p>
<p>就是JavaScript的月份范围用整数表示是0~11，0表示一月，1表示二月……，所以要表示6月，我们传入的是5！这绝对是JavaScript的设计者当时脑抽了一下，但是现在要修复已经不可能了。</p>
<p>如果我们还想要精确控制如何序列化小明，可以给xiaoming定义一个toJSON()的方法，直接返回JSON应该序列化的数据：</p>
<p>var xiaoming = {<br>    name: ‘小明’,<br>    age: 14,<br>    gender: true,<br>    height: 1.65,<br>    grade: null,<br>    ‘middle-school’: ‘\”W3C\” Middle School’,<br>    skills: [‘JavaScript’, ‘Java’, ‘Python’, ‘Lisp’],<br>    toJSON: function () {<br>        return { // 只输出name和age，并且改变了key：<br>            ‘Name’: this.name,<br>            ‘Age’: this.age<br>        };<br>    }<br>};</p>
<p>JSON.stringify(xiaoming); // ‘{“Name”:”小明”,”Age”:14}’</p>
<p>JS 的函数，传入多余数量的参数 ，不报错，而是自动忽略。</p>
<p>正确的方法是充分利用JavaScript对不存在属性返回undefined的特性，直接用短路运算符||计算：</p>
<p>location<br>location对象表示当前页面的URL信息。例如，一个完整的URL：</p>
<p><a href="http://www.example.com:8080/path/index.html?a=1&amp;b=2#TOP" target="_blank" rel="noopener">http://www.example.com:8080/path/index.html?a=1&amp;b=2#TOP</a><br>可以用location.href获取。要获得URL各个部分的值，可以这么写：</p>
<p>location.protocol; // ‘http’<br>location.host; // ‘<a href="http://www.example.com&#39;" target="_blank" rel="noopener">www.example.com&#39;</a><br>location.port; // ‘8080’<br>location.pathname; // ‘/path/index.html’<br>location.search; // ‘?a=1&amp;b=2’<br>location.hash; // ‘TOP’</p>
<p>要加载一个新页面，可以调用location.assign()。如果要重新加载当前页面，调用location.reload()方法非常方便。</p>
<p>document<br>document对象表示当前页面。由于HTML在浏览器中以DOM形式表示为树形结构，document对象就是整个DOM树的根节点。</p>
<p>document的title属性是从HTML文档中的<title>xxx</title>读取的，但是可以动态改变：</p>
<p>由于HTML文档被浏览器解析后就是一棵DOM树，要改变HTML的结构，就需要通过JavaScript来操作DOM。</p>
<p>插入 DOM</p>
<p>var<br>    list = document.getElementById(‘list’),<br>    haskell = document.createElement(‘p’);<br>haskell.id = ‘haskell’;<br>haskell.innerText = ‘Haskell’;<br>list.appendChild(haskell);</p>
<p>因为是异步操作，所以我们在JavaScript代码中就不知道什么时候操作结束，因此需要先设置一个回调函数：</p>
<p>$是著名的jQuery符号</p>
<p>实际上，jQuery把所有功能全部封装在一个全局变量jQuery中，而$也是一个合法的变量名，它是变量jQuery的别名：</p>
<p>按ID查找<br>var div = $(‘#abc’);<br>按tag查找<br>var ps = $(‘p’); // 返回所有</p><p>节点<br>ps.length; // 数一数页面有多少个</p><p>节点</p>
<p>按class查找</p>
<p>var a = $(‘.red’); // 所有节点包含<code>class=&quot;red&quot;</code>都将返回<br>// 例如:<br>// <div class="red">…</div><br>// </p><p class="green red">…</p><p></p>
<p>通常很多节点有多个class，我们可以查找同时包含red和green的节点：</p>
<p>var a = $(‘.red.green’); // 注意没有空格！<br>// 符合条件的节点：<br>// <div class="red green">…</div><br>// <div class="blue green red">…</div></p>
<p>按属性查找</p>
<p>var email = $(‘[name=email]’); // 找出&lt;??? name=”email”&gt;<br>var passwordInput = $(‘[type=password]’); // 找出&lt;??? type=”password”&gt;<br>var a = $(‘[items=”A B”]’); // 找出&lt;??? items=”A B”&gt;</p>
<p>当属性的值包含空格等特殊字符时，需要用双引号括起来。</p>
<p>组合查找<br>组合查找就是把上述简单选择器组合起来使用。如果我们查找$(‘[name=email]’)，很可能把表单外的<div name="email">也找出来，但我们只希望查找<input>，就可以这么写：</div></p>
<p>var emailInput = $(‘input[name=email]’); // 不会找出<div name="email"><br>同样的，根据tag和class来组合查找也很常见：</div></p>
<p>var tr = $(‘tr.red’); // 找出<tr class="red ...">…</tr></p>
<p>多项选择器<br>多项选择器就是把多个选择器用,组合起来一块选：</p>
<p>$(‘p,div’); // 把</p><p>和<div>都选出来<br>$(‘p.red,p.green’); // 把<p class="red">和</p><p class="green">都选出来</p>
</div></p></div></article></div><div id="disqus_thread"></div></div><div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;"><img src="/images/WechatIMG5.jpeg" width="180px"></div><div id="ads"></div><script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><!-- 底部01--><ins style="display:block" data-ad-client="ca-pub-7674654031652018" data-ad-slot="3127803056" data-ad-format="auto" class="adsbygoogle"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});

</script><div id="SOHUCS"></div><script charset="utf-8" type="text/javascript" src="https://changyan.sohu.com/upload/changyan.js"></script><script type="text/javascript">window.changyan.api.config({
appid: 'cytkri3BC',
conf: 'prod_1e787a373da7a5fa9ef7156a6dae5e6b'
});
</script></main><footer class="footer-container"><div class="paginator"><a href="/2018/05/07/nginx-转发js-跨域请求/" class="prev">PREV</a><a href="/2018/05/05/npm-脚本/" class="next">NEXT</a></div><div class="copyright"><p>© 2017 - 2018 <a href="mailto:fupeng_2005@126.com">kunpengku</a>, <a href="http://www.miitbeian.gov.cn">京ICP备17058936号-1</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/AngryPowman/hexo-theme-prontera" target="_blank">hexo-theme-prontera</a>.</p></div></footer><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"angrypowman",'auto');ga('send','pageview');</script></body></html>